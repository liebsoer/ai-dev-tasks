---
description: 
globs: 
alwaysApply: false
---
# Rule: Generating a Task List from a PRD

## Goal

To guide an AI assistant in creating a detailed, step-by-step task list in Markdown format based on an existing Product Requirements Document (PRD). The task list should guide a developer through implementing a Vue.js application using modern Vue 3 patterns, composables, and architectural best practices within an Nx monorepo structure.

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/[application-name]/` (e.g., `/tasks/user-profile/`)
- **Filename Structure:** The filename should be prefixed with `tasks-` followed by the base name of the PRD file, ensuring it is descriptive and matches the feature being implemented.
  - Example: If the PRD file is named `prd-user-profile-editing.md`, the task list file should be named `tasks-prd-user-profile-editing.md`.
- **Directory Structure:** The task list should be saved in a subdirectory named after the application or feature area, e.g., `/tasks/user-profile/`.
- **Filename:** `tasks-[prd-file-name].md` (e.g., `tasks-prd-user-profile-editing.md`)

## Process

1.  **Receive PRD Reference:** The user points the AI to a specific PRD file
2.  **Analyze PRD:** The AI reads and analyzes the functional requirements, user stories, and other sections of the specified PRD.
3.  **Phase 1: Generate Parent Tasks:** Based on the PRD analysis, create the file and generate the main, high-level tasks required to implement the feature. Use your judgement on how many high-level tasks to use. It's likely to be about 5. Present these tasks to the user in the specified format (without sub-tasks yet). Inform the user: "I have generated the high-level tasks based on the PRD. Ready to generate the sub-tasks? Respond with 'Go' to proceed."
4.  **Wait for Confirmation:** Pause and wait for the user to respond with "Go".
5.  **Phase 2: Generate Sub-Tasks:** Once the user confirms, break down each parent task into smaller, actionable sub-tasks necessary to complete the parent task. Focus on architectural decisions, component design patterns, Vue.js best practices, and Nx monorepo organization rather than specific file creation. Ensure sub-tasks logically follow from the parent task and cover the implementation patterns implied by the PRD.
6.  **Identify Relevant Architecture:** Based on the tasks and PRD, identify the Vue.js architectural components needed: Vue components, composables, stores, services, configuration modules, and Nx libraries for code sharing. List these under the `Relevant Components & Architecture` section.
7.  **Generate Final Output:** Combine the parent tasks, sub-tasks, architectural components, and notes into the final Markdown structure optimized for Vue.js development within an Nx workspace.
8.  **Save Task List:** Save the generated document in the `/tasks/` directory with the filename `tasks-[prd-file-name].md`, where `[prd-file-name]` matches the base name of the input PRD file (e.g., if the input was `prd-user-profile-editing.md`, the output is `tasks-prd-user-profile-editing.md`).

## Output Format

The generated task list _must_ follow this structure:

```markdown
## Relevant Components & Architecture

### Vue Components
- **ComponentName** - High-level description of purpose and functionality (e.g., Main navigation component with dynamic routing)
- **AnotherComponent** - Description of responsibility (e.g., Data visualization dashboard with reactive charts)

### Composables & Business Logic
- **useFeatureName** - Description of composable responsibility (e.g., Manages user authentication state and JWT tokens)
- **useAnotherFeature** - Description (e.g., Handles data fetching with caching and error states)

### Stores & State Management
- **FeatureStore** - Description of state management responsibility (e.g., Centralizes user preferences and app configuration)
- **DataStore** - Description (e.g., Manages application data with persistence and synchronization)

### Services & Utilities
- **ApiService** - Description of service layer (e.g., HTTP client with interceptors and error handling)
- **UtilityModule** - Description (e.g., Common helper functions for data transformation and validation)

### Nx Libraries & Shared Code
- **SharedLibrary** - Description of shared library functionality (e.g., Common UI components across multiple apps)
- **UtilityLibrary** - Description (e.g., Shared business logic and data models)
- **FeatureLibrary** - Description (e.g., Domain-specific functionality that can be reused)

### Infrastructure & Configuration
- **RouterConfiguration** - Description (e.g., Vue Router setup with guards and meta fields)
- **AppConfiguration** - Description (e.g., Vite build configuration and environment management)
- **NxConfiguration** - Description (e.g., Nx workspace configuration, targets, and generators)

### Notes

- Tasks should focus on architectural patterns and component design rather than specific file implementations
- Allow AI flexibility to choose optimal Vue 3 patterns (Composition API, script setup, etc.)
- Emphasize composable-first approach for business logic
- Consider Pinia for state management and Vue Router for navigation
- Use Vite as the build tool and TypeScript for type safety
- Leverage Nx for monorepo management, code sharing, and build optimization
- Create shared libraries for reusable components, utilities, and business logic
- Use Nx generators for consistent project structure and code generation
- Implement proper dependency management between apps and libraries
- Testing should cover component behavior, composable logic, and integration scenarios
- Use Nx's affected commands for efficient CI/CD and testing strategies

## Tasks

- [ ] 1.0 Nx Workspace Foundation & Vue.js Application Setup
  - [ ] 1.1 Generate Vue 3 application using Nx Vue plugin with TypeScript and Vite configuration
  - [ ] 1.2 Configure Nx workspace boundaries and dependency rules for library isolation
  - [ ] 1.3 Set up Vue Router with route guards and meta fields for navigation architecture
  - [ ] 1.4 Configure Pinia stores with proper module boundaries and TypeScript integration
  - [ ] 1.5 Establish Nx project tags and lint rules for consistent architecture enforcement

- [ ] 2.0 Shared Library Architecture & Design System
  - [ ] 2.1 Generate UI component library using Nx generators with Vue 3 Composition API patterns
  - [ ] 2.2 Create utilities library with shared composables and business logic functions
  - [ ] 2.3 Build data models library with TypeScript interfaces and validation schemas
  - [ ] 2.4 Implement theme library with design tokens and Vue-compatible styling system
  - [ ] 2.5 Generate feature-specific libraries with clear API boundaries and minimal coupling

- [ ] 3.0 Core Feature Implementation with Vue.js Patterns
  - [ ] 3.1 Implement Vue components using script setup syntax and TypeScript for optimal developer experience
  - [ ] 3.2 Create composables following single responsibility principle for business logic abstraction
  - [ ] 3.3 Design reactive state management with Pinia stores and proper reactivity patterns
  - [ ] 3.4 Build service layer with HTTP clients, error handling, and Vue integration
  - [ ] 3.5 Implement component composition patterns and slot-based architecture for flexibility

- [ ] 4.0 Testing Strategy & Quality Assurance
  - [ ] 4.1 Configure Vitest for unit testing of components and composables with Vue Test Utils
  - [ ] 4.2 Set up Nx affected commands for efficient testing of changed code across libraries
  - [ ] 4.3 Implement integration tests for cross-library interactions and data flow validation
  - [ ] 4.4 Create component testing strategies with accessibility and user interaction validation
  - [ ] 4.5 Establish end-to-end testing with Cypress or Playwright for critical user workflows

- [ ] 5.0 Build Optimization & Deployment Configuration
  - [ ] 5.1 Configure Nx build targets with Vite optimization for production bundles
  - [ ] 5.2 Set up affected build strategies for efficient CI/CD pipeline execution
  - [ ] 5.3 Implement code splitting and lazy loading patterns for optimal application performance
  - [ ] 5.4 Configure deployment pipelines with environment-specific builds and testing
  - [ ] 5.5 Establish monitoring and performance tracking for production applications
```

## Interaction Model

The process explicitly requires a pause after generating parent tasks to get user confirmation ("Go") before proceeding to generate the detailed sub-tasks. This ensures the high-level plan aligns with user expectations before diving into details.

## Target Audience

Assume the primary reader of the task list is a **junior to mid-level Vue.js developer** who will implement the feature within an Nx monorepo. Tasks should be described at an architectural level that allows flexibility in choosing specific Vue 3 patterns, file organization, and implementation approaches while maintaining best practices. Include guidance on Nx library creation, code sharing strategies, and monorepo-specific workflows.
